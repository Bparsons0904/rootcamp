{
  "version": "1.0",
  "lessons": [
    {
      "id": "fg",
      "command": "fg",
      "code": "fg",
      "title": "Bring Jobs to Foreground",
      "tags": ["processes", "job-control", "intermediate"],
      "level": "intermediate",
      "module": "processes",
      "about": {
        "what": "The `fg` command **brings a background or suspended job to the foreground**, making it the active process in your terminal. When a job is in the foreground:\n\n- It takes over your terminal\n- You can interact with it (type input, see output)\n- You can control it with Ctrl+C (kill) or Ctrl+Z (suspend)\n- It blocks other terminal commands until it finishes or is suspended\n\nTypical use cases:\n1. **Resume suspended jobs** - Bring back a vim session you suspended with Ctrl+Z\n2. **Interact with background jobs** - Bring a background program to foreground to see its output or provide input\n3. **Check job progress** - Foreground a long-running task to monitor its status\n\nCommand syntax:\n- `fg` - Bring the most recent job (marked with +) to foreground\n- `fg %1` - Bring job number 1 to foreground\n- `fg %2` - Bring job number 2 to foreground",
        "history": "The `fg` command was created alongside `bg` and `jobs` as part of the job control system introduced in BSD Unix at UC Berkeley in the late 1970s.\n\nThe problem it solved:\nBefore job control, there was no way to \"pause\" and \"resume\" programs. If you were editing a file in `vi` and needed to run a quick command, you had two bad options:\n1. Quit `vi`, losing your editing context\n2. Open another terminal (if you had one available)\n\nWith job control:\n1. Press Ctrl+Z to suspend `vi`\n2. Run your command\n3. Type `fg` to resume exactly where you left off\n\nThis workflow became second nature to Unix users:\n- Editing code in vim\n- Ctrl+Z to suspend\n- Compile the code\n- Run tests\n- `fg` to return to vim\n- Repeat\n\nThe name \"fg\" stands for **foreground**, the opposite of background. The terminology comes from the metaphor of a job being \"in front\" (foreground, active, visible) vs \"in back\" (background, passive, hidden).\n\n**Technical implementation:**\nWhen you run `fg`:\n1. The shell sends **SIGCONT** to resume the job (if stopped)\n2. The shell brings the job's process group to the foreground terminal group\n3. The shell redirects terminal I/O to the job\n4. The shell waits for the job to finish or be suspended again\n\nInterestingly, the job control system inspired similar features in Windows (though Windows doesn't have true job control) and GUI systems (task switching, minimizing windows).\n\n**Modern relevance:**\nWhile `tmux` and `screen` provide more sophisticated terminal management, `fg` remains valuable for:\n- Quick switching without multiplexer overhead\n- Shell scripts that manage jobs\n- Muscle memory from decades of Unix usage\n- Lightweight systems without tmux installed",
        "example": "```bash\n# Classic editor workflow\n$ vim file.txt\n# Press Ctrl+Z to suspend\n[1]+ Stopped   vim file.txt\n$ ls -la  # Do some work\n$ cat README.md\n$ fg  # Return to vim\n# vim resumes exactly where you left off\n\n# Managing multiple jobs\n$ vim config.py\n# Press Ctrl+Z\n[1]+ Stopped   vim config.py\n$ vim utils.py\n# Press Ctrl+Z\n[2]+ Stopped   vim utils.py\n$ jobs\n[1]- Stopped   vim config.py\n[2]+ Stopped   vim utils.py\n\n# Bring specific job to foreground\n$ fg %1\n# Now in config.py\n\n# Bring most recent job\n$ fg\n# Brings job marked with +\n\n# Bring previous job\n$ fg %-\n# Brings job marked with -\n\n# Foreground a running background job\n$ python server.py &\n[1] 12345\n# Later, want to see output:\n$ fg\n# Now server is in foreground, you see logs\n# Press Ctrl+C to kill it, or Ctrl+Z then bg to background again\n\n# Typical development cycle\n$ vim main.py\n# Edit code, then Ctrl+Z\n$ python main.py  # Test it\n$ fg  # Back to editing\n# Edit more, Ctrl+Z\n$ python main.py  # Test again\n$ fg  # Back to editing\n\n# Check what's stopped before bringing to foreground\n$ jobs\n[1]+ Stopped   vim file.txt\n$ fg %1\n# Resume vim\n```",
        "commonUses": [
          "**Resume text editors** - Return to vim/nano/emacs after running commands",
          "**Interactive programs** - Bring background programs to foreground to interact",
          "**Monitor output** - Foreground a background job to see its real-time output",
          "**Debug running jobs** - Bring jobs forward to check status or provide input",
          "**Quick task switching** - Toggle between editing and testing without multiple terminals"
        ]
      },
      "hints": [
        "Read the workflow guide to understand fg usage",
        "Learn the common editor pattern",
        "The completion code is in the complete-guide file"
      ],
      "sandbox": {
        "startDir": "foreground",
        "dirs": ["foreground"],
        "files": {
          "foreground/workflow.txt": "TYPICAL FG WORKFLOW: The Edit-Test Cycle\n\nThis is THE most common use of fg - the developer's workflow:\n\n1. Editing code\n   $ vim app.py\n   # Write some code...\n\n2. Need to test it\n   # Press Ctrl+Z\n   [1]+ Stopped   vim app.py\n\n3. Run the code\n   $ python app.py\n   Hello, World!\n   # Output shows\n\n4. Back to editing\n   $ fg\n   # vim resumes, cursor exactly where you left it\n\n5. Edit more code\n   # Make changes...\n\n6. Test again\n   # Press Ctrl+Z\n   $ python app.py\n   # See new output\n\n7. Back to editing\n   $ fg\n\n========================\nWHY THIS IS POWERFUL:\n========================\n\nWithout fg:\n- Save and quit editor\n- Run tests\n- Reopen editor\n- Find where you were\n- Repeat\n\nWith fg:\n- Ctrl+Z (instant)\n- Run tests\n- fg (instant)\n- Right back where you were\n- Repeat\n\n5 steps → 3 steps\n15 seconds → 2 seconds\nContext lost → Context preserved\n\n========================\nMUSCLE MEMORY:\n========================\n\nAfter learning fg, your fingers automatically:\n1. Ctrl+Z when you need the shell\n2. fg when you want to return\n\nIt becomes as natural as breathing.\nNo thought required.\nPure productivity.",
          "foreground/scenarios.txt": "FG Usage Scenarios:\n\n=== Scenario 1: The Forgotten Background Job ===\n$ python server.py > logs.txt &\n[1] 45678\n# Working on other stuff...\n# Wait, is the server working?\n$ fg\n# Now you can see output and interact\n# Press Ctrl+C to stop, or Ctrl+Z + bg to background again\n\n=== Scenario 2: Multiple Suspended Editors ===\n# Working on different parts of a project\n$ vim frontend/app.js\n# Ctrl+Z\n[1]+ Stopped   vim frontend/app.js\n\n$ vim backend/server.py\n# Ctrl+Z\n[2]+ Stopped   vim backend/server.py\n\n$ vim database/schema.sql\n# Ctrl+Z\n[3]+ Stopped   vim database/schema.sql\n\n# Check what's suspended\n$ jobs\n[1]  Stopped   vim frontend/app.js\n[2]- Stopped   vim backend/server.py\n[3]+ Stopped   vim database/schema.sql\n\n# Jump to specific file\n$ fg %1  # Back to app.js\n$ fg %2  # Switch to server.py\n$ fg %3  # Switch to schema.sql\n\n=== Scenario 3: Interactive Debug Session ===\n$ python -i debug.py\n# In Python REPL, testing...\n# Ctrl+Z to suspend\n[1]+ Stopped   python -i debug.py\n\n# Check a file\n$ cat data.json\n\n# Back to Python session\n$ fg\n>>> # Continue debugging\n\n=== Scenario 4: Long-Running Task Check ===\n$ rsync -av /source /dest &\n[1] 12345\n# ... time passes ...\n# How's it going?\n$ fg\n# See current file being copied\n# Press Ctrl+Z + bg to background again\n\n=== Scenario 5: The \"Oops\" Recovery ===\n$ ./configure && make && make install\n# Oh no, this will take forever!\n# Ctrl+Z\n[1]+ Stopped   bash\n$ bg  # Let it continue in background\n# Later, want to see progress:\n$ fg",
          "foreground/complete-guide.txt": "Complete FG Command Guide:\n\n================================\nCODE: FG-FOREGROUND-MASTER\n================================\n\nCOMMAND SYNTAX:\nfg            → Foreground current job (marked with +)\nfg %1         → Foreground job number 1\nfg %2         → Foreground job number 2\nfg %-         → Foreground previous job (marked with -)\nfg %?string   → Foreground job containing 'string' in command\nfg %%         → Foreground current job (same as fg)\n\nJOB STATES:\nStopped → Job is suspended (paused)\n  - Was suspended with Ctrl+Z\n  - Use fg to resume in foreground\n  - Use bg to resume in background\n\nRunning (background) → Job is active but in background\n  - Started with & or backgrounded with bg\n  - Use fg to bring to foreground\n  - Still executing, just not visible\n\nRunning (foreground) → Job is active and controlling terminal\n  - Current state after fg\n  - Can Ctrl+Z to suspend\n  - Can Ctrl+C to kill\n\nFG WORKFLOW:\n1. Identify job to foreground: jobs\n2. Bring to foreground: fg %N\n3. Job resumes and takes control\n4. Interact with it normally\n5. Suspend (Ctrl+Z), kill (Ctrl+C), or let it finish\n\nKEY CONCEPTS:\n\nForeground means:\n- Job receives your keyboard input\n- Job's output appears on your screen\n- Job blocks your terminal\n- You can control it (Ctrl+C, Ctrl+Z)\n\nBackground means:\n- Job doesn't receive keyboard input\n- Job's output may still appear (annoying!)\n- Job doesn't block your terminal\n- You continue working\n\nCOMMON MISTAKES:\n\n1. Forgetting which job is which\n   → Solution: Use 'jobs' to check\n\n2. Bringing wrong job to foreground\n   → Solution: Use job numbers (fg %1)\n\n3. Background job writing to terminal\n   → Solution: Redirect output (command > file 2>&1 &)\n\nPRO TIPS:\n\n- fg is fastest without job number (brings most recent)\n- Use Ctrl+Z → fg to \"pause\" and \"resume\" quickly\n- 'jobs -l' shows PIDs if you need them\n- Background jobs survive fg/bg cycling\n- Combine with 'disown' to detach jobs from shell\n\nRELATED COMMANDS:\nCtrl+Z → Suspend foreground job\njobs   → List all jobs\nbg     → Resume job in background\nkill   → Terminate job by ID\ndisown → Detach job from shell\n\nTHE POWER USER CYCLE:\n1. vim file.txt\n2. Ctrl+Z\n3. make test\n4. fg\n5. Repeat\n\nMaster this, and you'll never need multiple terminal windows for simple tasks!"
        }
      },
      "instructions": "## Your Task\n\nLearn about the `fg` command for bringing jobs to the foreground.\n\n**Steps:**\n1. Read the workflow guide: `cat workflow.txt`\n   - Understand the edit-test cycle\n2. Read the scenarios: `cat scenarios.txt`\n   - See real-world examples\n3. Read the complete guide: `cat complete-guide.txt`\n   - Master fg usage\n4. Copy the completion code\n5. Type `exit` and paste the code\n\n**Try it yourself** (after this lesson):\n```bash\n# Classic workflow\nvim test.txt\n# Press Ctrl+Z\njobs\n# Shows: [1]+ Stopped vim test.txt\nfg\n# Back in vim!\n\n# Multiple jobs\nvim file1.txt\n# Ctrl+Z\nvim file2.txt\n# Ctrl+Z\njobs\n# Shows both jobs\nfg %1  # Jump to file1\nfg %2  # Jump to file2\n```\n\n**Remember:** The Ctrl+Z → command → fg cycle is a fundamental Unix workflow!",
      "requirements": [
        {
          "type": "command_output",
          "description": "The completion code from complete-guide.txt",
          "validator": "exact",
          "expected": "FG-FOREGROUND-MASTER"
        }
      ]
    }
  ]
}
